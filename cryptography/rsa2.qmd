# RSA scheme II


## Security

Finally, let's explore how secure the RSA scheme really is.

Specifically, let's consider the case where as an attacker, you already know the public key ($n$ and $e$) as well as the cipher text, $c = m^e \bmod n$.
Can you recover the message $m$?

> **Exercise 1:** Suppose you know that $n = 143$ and $e = 7$. You also know the encoded message is $c = 41$. Can you recover the decoded message $m$? <!-- Ans: d = 103, m = 50 -->
>
> > Hint: The message can be recovered using the formula $m = c^d \bmod n$.
> >
> > Since you already know $n$ and $c$, the only thing you need to find is $d$. Recall that $d$ is specified by the equation $de \equiv 1 \bmod \phi$, and $\phi = (p - 1)(q - 1)$.
> >
> > Once you have found $d$, you can key in its value below to quickly calculate $m$, and submit your answer.
>
> <div>
> If *c* = &nbsp;<input type="text" size=4 id="c1" value="41" />, *d* = <input type="text" size=4 id="d1" />, and *n* = <input type="text" size=4 id="n1" value="143" />, then *m* is: <span id="m1-calc">
> </div>
> <p></p>
> <div>
> Your answer: *m* = &nbsp;<input type="text" size=4 id="m1-answer" /> <input type="button" value="Check" id="check-m1" />&nbsp;&nbsp;&nbsp;&nbsp;<span id="m1-result"></span>
> </div>

<script type="module">
// calculates (base ^ exp) % mod while avoiding overflow/rounding errors
function powmod(base, exp, mod) {
    let result = 1;
    for (let i = 0; i < exp; i++) {
        result = (result * base) % mod;
    }
    return result;
}
function verifyContents(inputId) {
    let d = document.getElementById(inputId).value;
    d = d.replace(/\D/g, "");
    document.getElementById(inputId).value = d;
}
function calculateM() {
    const c = parseInt(document.getElementById("c1").value);
    const d = parseInt(document.getElementById("d1").value);
    const n = parseInt(document.getElementById("n1").value);
    if (isNaN(c) || isNaN(d) || isNaN(n)) {
        document.getElementById("m1-calc").innerHTML = "";
    }
    else {
        const m = powmod(c, d, n);
        document.getElementById("m1-calc").innerHTML = m;
    }
}
document.getElementById("c1").addEventListener("input", () => {verifyContents("c1"); calculateM();});
document.getElementById("d1").addEventListener("input", () => {verifyContents("d1"); calculateM();});
document.getElementById("n1").addEventListener("input", () => {verifyContents("n1"); calculateM();});

const correctAnswer = 50;
const wrongColor = "#fad9d7";  // light red
const rightColor = "#d7fae9";  // light green
function checkM(){
    const d = parseInt(document.getElementById("m1-answer").value);
    console.log(d)
    if (d === correctAnswer) {
        document.getElementById("m1-result").innerHTML = "Correct!";
        document.getElementById("m1-result").style.color = "green";
        document.getElementById("m1-answer").style.backgroundColor = rightColor;
    } else {
        document.getElementById("m1-result").innerHTML = "Incorrect. Try again.";
        document.getElementById("m1-result").style.color = "red";
        document.getElementById("m1-answer").style.backgroundColor = wrongColor;
    }
}
document.getElementById("check-m1").addEventListener("click", checkM);
document.getElementById("m1-answer").addEventListener("input", function(){
    verifyContents("m1-answer");
    document.getElementById("m1-answer").style.backgroundColor = "white";
    document.getElementById("m1-result").innerHTML = "";
});
</script>

> **Exercise 2:** Suppose you know that $n = 373577$ and $e = 7$. You also know the encoded message is $c = 226918$. Can you recover the decoded message $m$, using the same strategy as above?  <!-- Ans: d = 319063, m = 500 -->
>
> Chances are, you can't do this on your own! However, if you're feeling confident, you can try to guess the answer anyway:
>
> <div>
> Your answer: *m* = &nbsp;<input type="text" size=4 id="m2-answer" /> <input type="button" value="Check" id="check-m2" />&nbsp;&nbsp;&nbsp;&nbsp;<span id="m2-result"></span>
> </div>

<script type="module">
const correctAnswer = 500;
const wrongColor = "#fad9d7";  // light red
const rightColor = "#d7fae9";  // light green
function verifyM2contents() {
    let d = document.getElementById("m2-answer").value;
    console.log(d);
    d = d.replace(/\D/g, "");
    console.log(d);
    document.getElementById("m2-answer").value = d;
}
function checkM(){
    const d = parseInt(document.getElementById("m2-answer").value);
    console.log(d)
    if (d === correctAnswer) {
        document.getElementById("m2-result").innerHTML = "Correct!";
        document.getElementById("m2-result").style.color = "green";
        document.getElementById("m2-answer").style.backgroundColor = rightColor;
    } else {
        document.getElementById("m2-result").innerHTML = "Incorrect. Try again.";
        document.getElementById("m2-result").style.color = "red";
        document.getElementById("m2-answer").style.backgroundColor = wrongColor;
    }
}
document.getElementById("check-m2").addEventListener("click", checkM);
document.getElementById("m2-answer").addEventListener("input", function(){
    verifyM2contents();
    document.getElementById("m2-answer").style.backgroundColor = "white";
    document.getElementById("m2-result").innerHTML = "";
});
</script>


You probably found that the key to cracking the message is figuring out the prime factors $p$ and $q$.
Once you have those, you can calculate $\phi$ easily, and then $d$ using the extended Euclidean algorithm.

In the first case, this was easy enough.
But in the second case, finding $p$ and $q$ is a lot harder, because $n$ is a lot bigger.

But, we could get a computer to do it!


## Prime factorisation

TODO: Javascript widget that factorises the product of two primes and shows the time taken.

TODO: Maybe get the students to make a plot of log(time) vs number of digits in the product, or make another widget that does that for a given input.

> **Question:** How large do we need the numbers to be to make it reasonably secure?

## RSA in practice

How large do we actually make it?
